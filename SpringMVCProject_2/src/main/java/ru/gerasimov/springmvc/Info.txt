Здесь заменяем XML на Java класс
 web.xml --> Java класс
 applicationContext.xml --> Java класс (@Configuration)
========================================================================================================================
Чем заменить web.xml
Начиная с 3 версии Spring Framework можно использовать Java код вместо web.xml

для этого необходимо в проекте создать Java класс, который реализует интерфейс:
org.springframework.web.WebApplicationInitializer

public class MyWebAppInitializer implements WebApplicationInitializer {
@Override
public void onStartup(ServletContext container){
//код, который до этого помещался в web.xml
}
}
Такой класс считывается автоматически и работает как web.xml
Но мы будем использовать для конфигурации абстрактный класс:
AbstractAnnotationConfigDispatcherServletInitializer

Этот класс был представлен в Spring 3.2 и он реализует интерфейс WebApplicationInitializer за нас

                                 ----------------------------
                                 | WebApplicationInitializer|
                                 ----------------------------
                                              ^
                                              |
                     --------------------------------------------------------
                     | AbstractAnnotationConfigDispatcherServletInitializer |
                     --------------------------------------------------------
                     в этом классе WebApplicationInitializer реализован за нас.
                       Нам останется лишь подставить оставшиеся мелочи
========================================================================================================================
(1) удалим все xml конфигурации
(2) создали класс SpringConfig
- реализовываем интерфейс WebMvcConfigurer и вместе с ним реализуем метод configureViewResolvers
(3) далее идем в Java класс который у нас заменяет web.xml(MySpringMVCDispetcherServletInitializer)
(4) добавим еще одну зависимость
<!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api -->
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>4.0.1</version>
    <scope>provided</scope>
</dependency>

эта зависимость используется классом AbstractAnnotationConfigDispatcherServletInitializer
========================================================================================================================
========================================================================================================================
                                                 КОНТРОЛЛЕРЫ
- обрабатывают запросы от пользователя
- обмениваются данными с моделью
- Показывают пользователю правильное представление
- Переадресовывают пользователя на другие страницы

Аннотация @Controller
- помечает класс - контроллер
- Наследуется от аннотации @Component
- Поэтому, @ComponentScan работает с @Controller так же, как и просто с @Component
- @Controller - тот же @Component, но с дополнительными возможностями

Методы контроллеров
- Методов может быть несколько в контроллере
- Обычно(но не всегда), каждый метод соответствует одному URL'у
- Обычно(но не всегда), методы возвращают строку (String)-название представления, которое надо показать пользователю
- У методов может быть любое название

Маппинг
Адрес задается с помощью маппинга
@GetMapping("/hello-world")
- @GetMapping
- @PostMapping
- @PutMapping
- @DeleteMapping
- @PatchMapping
Иногда пишут(устаревший вариант):@RequestMapping(method = RequestMethod.GET)
- Связывают метод контроллера с адресом, по которому можно к этому методу обратиться(из браузера,например)
- Всего 5 разных видов маппинга - в зависимости от того, какой HTTP запрос(с каким HTTP методом) должен прийти в
этот метод контроллера

(1) Создали папку Controllers в которой будут хранится наши Java классы контроллеры
- Создали класс FirstController и добавили два метода

    @GetMapping("/hello")
    public String helloPage(){
        return "first/hello"; //они будут лежать в папке first
    }
    @GetMapping("/goodbye")
    public String goodByePage(){
        return "first/goodbye"; //они будут лежать в папке first
    }
(2) Создали две HTML страницы
(3) Теперь усложним и сделаем переход по ссылке с одной страницы на другую
<a href="/hello">Say hello</a> это делается через тег "a" у этого тега есть аргумент href"адрес"
аналогично с другой страницей
те при нажатии на эти ссылки мы будем переходить по адресу и попадать на соответсвтующий метод контроллера
(4) Создадим еще один класс контроллер c методом exit();

========================================================================================================================
========================================================================================================================
Протокол HTTP. Методы GET и POST
этот протокол является стандартом для взаимодействия компьютера в сети.

Клиент - сервер
       HTTP-запрос(request)
клиент -----------> Сервер | URL (Uniform Resource Locator)
клиент <----------- Сервер | localhost:8080
       HTTP-ответ(response)
Мы реализовали контроллеры и обращались к ним из браузера это взаимодействие может быть описана такой диаграмой как выше
клиент - браузер и из это браузера мы делали HTTP запросы к серверу, на сервере работало Spring приложение и к этому
Spring приложению мы получали доступ по его URL(localhost:8080), где 8080 это его порт на котором работает Spring
приложение. И от нашего сервера мы получли ответы HTTP-response и в нашем случае эти ответы были html страницы, которые
отображались в нашем браузере.
========================================================================================================================
HTTP-request
Структура

GET/wiki/java HTTP/1.1      -- Стартовая строка
метод запроса/адрес/используемый протокол

Host: ru.wikipedia.org    |
User-Agent: Mozilla/5.0   | -- Заголовки (Headers)
Accept: text/html         |
     ...                    -- Пустая строка разделяет заголовки и тело

k1=v1&k2=v2&k3=v3           -- Тело (Body)
               может быть пустым
========================================================================================================================
Методы HTTP-request
Методы дают понять серверу какое действие хочет сделать клиент.
-GET  | Самые используемые
-POST |              методы
-PUT
-PATCH
-DELETE
========================================================================================================================
GET-request
-"Получить"
-Самый используемый запрос (переход по адресу,переход по ссылке,поисковой запрос в Google,открытие видео на YouTube,тд)
-Идемпотентный(ничего не меняет на сервере)
-Тело запроса пустое
GET-request он нужен для того чтобы получить данные с сервера при этом мы с помощью GET-request не можем изменять данные
на сервере и у GET-request тело запроса всегда пустое тк нам не надо посылать каких то особых данных на сервер, мы не можем
с помощью GET-request загружать данные на сервер по этому тело всегда пусто. Но иногда нам необходимо послать какие то
параметры в GET-request и в этом случае мы их посылаем в самом URL (парметры)

Параметры
https://vk.com/audios33064131?Q=GERSHWIN&SECTION=PLAYLIST

Параметры нужны для передачи информации от клиента к серверу во время запроса
-Параметры GET-запроса передаются в самом URL после знака ? в формате КЛЮЧ=ЗНАЧЕНИЕ (тело GET-request всегда пустое)
-Несколько параметров(пар КЛЮЧ=ЗНАЧЕНИЕ)разделяются знаком &.
========================================================================================================================
POST-request
-"Публиковать"
-Цель запроса-изменить что-то на сервере(чаще всего-добавить что нибудь)
-Часто используется для отправки данных с веб-форм, но не только для этого(создать новую учетную запись,
твитнуть что-нибудь, добавить запись в сообщество, загрузить фото в IG, и т.д.)
-Все параметры хранятся в теле запроса

Параметры
https://mysite.com/test(?key1=v1&key2=v2)
-Все парметры закодированы в теле запроса(в отличии от GET)
-Content-Type может быть разный(JSON,XML,и тд)
-В зависимости от Content-Type меняется и формат данных в теле запроса

POST/test HTTP/1.1                               --Здесь метод запроса POST
Host: mysite.com                               |
User-Agent: Mozilla/5.0                        | --Заголовки
Accept: text/html                              |
Content-Type: application/x-www-form-urlencoded  --в этом заголовке описывается тот тип данных который передается в теле
                                                   запроса
              ...

        key1=v1&key2=v2                          -- Тело (параметры передаются строго в теле запроса)
========================================================================================================================
Сравнение

              GET
1.Нужен для ПОЛУЧЕНИЯ данных с сервера
2.Тело запроса всегда пустое
3.URL МОЖЕТ СОДЕРЖАТЬ параметры
4.Может передовать ТОЛЬКО ПАРЫ КЛЮЧ=ЗНАЧЕНИЕ

              POST
1.Нужен для ИЗМЕНЕНИЯ данных на сервере
2.Тело запроса МОЖЕТ СОДЕРЖАТЬ различные данные
3.URL НЕ СОДЕРЖИТ парметры(они в теле)
4.Может ПЕРЕДАВАТЬ РАЗЛИЧНЫЕ ДАННЫЕ (пары ключ=значение, Java объекты, файлы,тд)
========================================================================================================================
HTTP-response
структура

HTTP/1.1 200 OK           -- стартовая строка
используемый протокл/код ответа
Date: Wed, 17 Jun 2020   |
Server: Apache           |-- Заголовки(Headers)
Content-Type: text/html  |
тип контента в теле ответа
         ...

<h1>Hello world!<h1>      -- Тело(Body)
========================================================================================================================
Статус ответа
- 200 - все ок
- 3xx - Редирект (сервер хочет чтобы наш браузер перешел на какую нибудь другую страницу)
- 4xx - Ошибка клиента
- 5xx - Ошибка сервера
========================================================================================================================
Тип содержимого(Content-Type)
-text/html  <--- так мы делали
-text/css
-text/xml
-application/json
========================================================================================================================
========================================================================================================================




















